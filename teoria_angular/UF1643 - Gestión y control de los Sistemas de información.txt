UF1643 - Gestión y control de los Sistemas de información


-------------------------------------------------------------------

comandos:
	- Crear nueva app: ng new my-app
	- Abrir el servidor: ng serve --open
	- Crear componentes: ng g c paginas/inicio
	- Crear directivas: ng g d directivas/subrayar
	- Crear filtros: ng g pipe pipes/animales
	- Crear servicio: ng g s services/tareas
	- Abrir puerto para ver json: json-server --watch db.json --> http://localhost:3000/tareas (elegimos el json que necesitemos)
	- Crear guarda: ng g g guards/login --> seleccionar con el espacio la opción de canActivate e intro
	
	- Could not find module "@angular-devkit/build-angular" from... (angularFrutas 08/02/2020) --> npm install --save-dev @angular-devkit/build-angular	

	- Subir a producción: ng build --prod
	- Subir a producción con una base url: ng build --prod --base-href=/pokemon-angular-ana/

-------------------------------------------------------------------


28/01/2020

- Trabajando con Arrays (programación funcional)
	map, filter, find y reduce --> sirven para trabajar con una colección de datos
	- map: obtenemos otra colección de datos transformada a partir de la inicial. Devuelve un array de la misma long que el original pero distinto
	- filter: hace un filtro de la colección de datos. Si la condición es true, devuelve el objeto completo sobre el que iteramos; si no, no devuelve nada
	- reduce: devuelve un objeto a partir del array inicial, es decir, reduce los datos a uno sólo
	- find: busca el 1er objeto que cumple una condición

	ver imagen: map filter find reduce

	- Un map de lista a lista
		https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/map
		- map crea una nueva array mediante la transformación de cada elemento en una array, de forma individual
	- Filtrar
		https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/filter
		- filter crea una nueva matriz eliminando los elementos que no pertenecen
	- Reducción de Arrays
		https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/reduce
		- reduce toma todos los elementos en un array, y los reduce en un sólo valor
			IMPORTANTE: reduce devuelve un solo valor, no un array que contiene un único elemento
		- reduce pasa la devolución de llamada cuatro argumentos: valor actual, valor anterior, índice actual, array con el que se llama a reduce. 
			No siempre tienen que aparecer estos 4 argumentos, el 3ero y el 4o son opcionales
		- reduce en la práctica
	- Find buscando dentro de los Arrays
		https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/find
		- find() devuelve el valor del 1er elemento del array que cumple la función de prueba proporcionada. En cualquier otro caso devuelve undefined
		- find no transforma el array desde el cual es llamado
		

-------------------------------------------------------------


04/02/2020:


- TypeScript:

	- es un lenguaje de programación libre y de código abierto desarrollado y mantenido por Microsoft
	- tipado estático opcional: poniendo los 2 puntitos
	- genéricos: se hace una clase (IDAO) y cuando se herede, se indica su tipo: public class ReseniaDAO implements IDAO<Resenia>
	- TypeScript se compila en javascript
	- Pagina oficial: http://www.typescriptlang.org/docs/home.html
	- Repositorio en GITHUB: https://github.com/Microsoft/TypeScript

	- se puede usar para desarrollar aplicaciones JavaScript que se ejecutarán en el cliente o en el servidor (Node.js), o también para frontend (Angular).
	- se trata de un superconjunto de Javascript, es decir, amplía Javascript con una nueva sintaxis que añade, entre otras cosas, el tipado estático opcional, genéricos, decoradores y elementos de POO como interfaces o property accessors.
	- TypeScript compila código JavaScript que se ejecuta en cualquier navegador, host, sistema operativo o motor de JavaScript que admita ECMAScript 3 (o más reciente). --> ES6 o ECMAScript2015

	- esquema círculos
	- ES5: ecma scritp, se encarga de definir cómo funciona javascript

	- Por qué Typescript
		- diseñado para ejecutarse en un navegador y hacer cosas simples con html
		- con técnicas como el tipado estático opcional y/o la encapsulación para generar un código mucho más mantenible y escalable que con JavaScript tradicional, sin perder el carácter dinámico del mismo.

	- Watcher: escucha y cada vez que hacemos un cambio, lo coge al vuelo
		es decir, cada vez que guardemos las modificaciones el fichero se compilará automáticamente

	- Sistema de tipos:
		- principal característica de Typescript 
		- realiza una formalización de los tipos de Javascript, mediante una representación estática de su sistema de tipado dinámico
		- variables con let en lugar de var:
		
		let myName: string = "Miguel";
		let printName = (name: string) => {
    			console.log(name);
		}

		- en el fichero main.js se guardan todos los ficheros compilados

		TypeScript admite los siguientes tipos de datos:
		- String 
		- Number
		- Boolean: tipo de dato logico que representa verdadero o falso.
		- Array: tipo de dato estructurado que permite almacenar una colección de elementos.
		- Tuple: similar al array, pero con un número fijo de elementos escritos.
		- Enum: representa al tipo enumeración. Una enumeración es una forma de dar nombres descriptivos a los conjuntos de valores numéricos
			--> ejemplos: 
				- https://jarroba.com/enum-enumerados-en-java-con-ejemplos/
				- http://www.typescriptlang.org/docs/handbook/enums.html
			son siempre ctes
			ej. estaciones: primavera, verano, otoño, invierno y cada uno estaría identificado con un número de forma que sólo se pueda elegir uno de esos valores y ningún otro
		- Any: indica que la variable puede ser de cualquier tipo. Es muy útil a la hora de trabajar con librerías externas.
			se suele usar con servicios rest porque sabemos que nos devuelve un json, pero un json no es un tipo concreto (dentro puede tener datos string, number...)
		- Void: indica que una función no devolverá ningún valor.
		- Never: este tipo representa el tipo de valores que nunca se producen. Por ejemplo para indicar que una función siempre arroja una excepción o que nunca termina su ejecución.
		- ejemplos en doc oficial --> http://www.typescriptlang.org/docs/handbook/basic-types.html

		- Ejemplo:
			// 1 - declaracion del tipo
			type Ranking = [number, string, boolean];
			// 2 - definición de variables 
			let position: number;
			let playerName: string;
			let finishedGame: boolean;
			let ranking: Ranking;
			let hallOfFame: Array<Ranking> = [];	
			// 3 - crea un ranking
			position = 1;
			playerName = "Bruno Krebs";
			finishedGame = true;
			ranking = [position, playerName, finishedGame];
			hallOfFame.push(ranking);
			// 4 - crea otro ranking
			position = 2;
			playerName = "Maria Helena";
			finishedGame = true;
			ranking = [position, playerName, finishedGame];
			hallOfFame.push(ranking);
			// 5 - define una funcion que recorre todos los rankings
			function printRankings(rankings: Array<RankingTuple>): void {
			  for (let ranking of rankings) {
			    console.log(ranking);
			  }
			}
			// 6 - llama a la función
			printRankings(hallOfFame);

	- Iteraciones:
		- for … in: permite recorrer objetos iterables obteniendo sus indices
		- for … of: permite recorrer colecciones obteniendo su valor
		
		let list = [4, 5, 6];
		for (let i in list) {
   			console.log(i); // "0", "1", "2" <-- indices
		}
		for (let i of list) {
   			console.log(i); // "4", "5", "6" <-- valores
		}

	- Módulos:
		- Otra de las características de Typescript es heredada de ECMAScript 2015: la posibilidad de crear módulos
		- una forma de encapsular código en su propio ámbito. 
		- Nos permiten agrupar nuestro código en diferentes ficheros, permitiéndonos exportarlos y utilizarlos donde los necesitemos. 
		- nos facilita la tarea de crear software más ordenado y por ende más escalable y mantenible.
		- se usan las palabras reservadas export e import

		- TypeScript también soporta otra serie de funcionalidades como:
			- Clases y Objetos
			- Herencia
			- Interfaces
			- Clases Abstractas
			- Getters y Setters
			- Decoradores

	- extra: Videos Youtube: Introducción al curso de TypeScript para Angular 2 en Español --> https://www.youtube.com/watch?v=vFJT8pX0eXs&list=PLBdkl5-ytBTw28OJMumO-iUxYnShbhqwO





- SASS
	- no hay que instalar nada porque ya lo tiene el propio framework
	- https://sass-lang.com/guide
		- sass --watch input.scss output.css --> ficheros de entrada y salida
		- Variables
			$color_pink:#da9393; //Variable
			h1{
    				color: $color_pink; //usamos la variable que hemos creado
			}
		- ng build --prod --> genera una carpeta con un fichero para dejar en el servidor de producción (dist\angularApp)
			- main.js --> contiene todos los componentes del desarrollo
			- runtime --> código fuente
			- polyfills --> plugins/parches por si algo no funciona bien nativamente

C:\0396\angularApp\angularApp>ng build --prod
Generating ES5 bundles for differential loading...
ES5 bundle generation complete.

chunk {0} runtime-es2015.edb2fcf2778e7bf1d426.js (runtime) 1.45 kB [entry] [rendered]
chunk {0} runtime-es5.edb2fcf2778e7bf1d426.js (runtime) 1.45 kB [entry] [rendered]
chunk {2} polyfills-es2015.2987770fde9daa1d8a2e.js (polyfills) 36.4 kB [initial] [rendered]
chunk {3} polyfills-es5.6696c533341b95a3d617.js (polyfills-es5) 123 kB [initial] [rendered]
chunk {1} main-es2015.c98ae739d9a85f89df4a.js (main) 255 kB [initial] [rendered]
chunk {1} main-es5.c98ae739d9a85f89df4a.js (main) 310 kB [initial] [rendered]
chunk {4} styles.c028f661f79f7de98b90.css (styles) 154 kB [initial] [rendered]
Date: 2020-02-04T08:31:05.717Z - Hash: 06f190c2d3e45465a52c - Time: 55728ms

		- Nesting: en este ejemplo aplicamos estilos a las etiquetas code que estén dentro de p
			p {
    				code {
        				color: $color_green;
        				background-color: $color_black;
        				padding: 2px 3px;
    				}
			}
		- Partials: es una especie de import (y está montado), es como hacer imports de pequeños cachitos de sass. 
			Se distingue porque su nomenclatura es _partial.scss, se importa como import partial (sin _ ni extensión)
		- Modules: para importar otro fichero de estilo en el orden en el que queramos, @use 'base';
		- Mixins: define una función y se la aplica a un componente 
			//mixins o funciones para reutilizar:
			@mixin redondear( $radio, $color ) {
			    border-radius: $radio;
			    border: 1px solid $color;
			    padding: 10px;
			}
			.borde10{
			    @include redondear(10px, $color_pink); //usamos mixin
			}
			.borde50{
			    @include redondear(50%, #FF0000);
			}
		- Extend/Inheritance
			//Herencia (Extend/Inheritance):
			%boton {
    				@include redondear(45%, $color_black);
    				border: 3px solid;
    				padding: 10px;
    				color: white;
    				background-color: #2A272A;
			}
			.boton-verde {
			    @extend %boton;
			    background-color: #356840;
			    border-color: darkolivegreen;
			    &:hover { //aplicamos nesting en el pseudoselector para hacer el hover
			        background-color: rgb(73, 156, 84);
			    }
			}
	




- Angular Curso Practico Completo, Desde Cero, Para Principiantes
	https://www.youtube.com/watch?v=Sx_2dOYOtes
 
- Manual Angular Castellano (pdf)
	- componentes
	- Data Binding Flow: es el envío entre el controlador y las páginas, ej llevar un título a inicio
	- Dependency Injection: Lazy SPA --> se cargan los datos cuando se necesitan, no desde el principio, ej, lista de cursos y su detalle (el detalle tendrá más datos)
	- se trabaja con Typescript pero puede compilar a ES2015/6
	- Crear el esqueleto de una aplicación Angular 2

	- Scripts de npm

		"scripts": {
    			"ng": "ng",
		    "start": "ng serve",
 		   "build": "ng build",
 		   "test": "ng test",
 		   "lint": "ng lint",
 		   "e2e": "ng e2e"
		}

	- Archivos y carpetas con un proyecto de Angular 2.1 y Angular 4
		- index.html: pag principal y en la que metemos el componente principal <app-root></app-root>
			"app-root" es el componente raíz de la aplicación. En el desarrollo basado en componentes es un 
			patrón normal que toda la aplicación se construya en un componente principal, del que colgará todo un
			árbol de componentes especializados en hacer cada una de las cosas necesarias.
		- package.json: resume las dependencias del proyecto, las librerías sobre las que nos apoyamos, que se gestionan por medio de npm.
		- Carpeta node_modules: carpeta donde npm va colocando todas las dependencias del proyecto, es decir, el código de todas las
			librerías o componentes que estemos usando para basarnos en el desarrollo de una aplicación. Por ejemplo,
			el propio Angular es una dependencia
		- Carpeta src: Es la carpeta donde están las fuentes del proyecto. Esta carpeta es la que usaremos para desarrollar la
				aplicación y donde iremos colocando componentes y otro tipo de artefactos necesarios para poner en marcha nuestras ideas.
				- Es la carpeta más interesante para ti como desarrollador, ya que es el lugar donde colocarás el código
				fuente de tu proyecto. En realidad más en concreto la carpeta "app" que encontrarás dentro de "src" es
				donde tienes que programar tu aplicación. Observarás que ya viene con diversos contenidos, entre otras
				cosas el index.html que debe servir como página de inicio. No obstante, no es exactamente el directorio raíz
				de publicación, porque al desplegar el proyecto los resultados de compilar todos los archivos se llevarán a la
				carpeta "dist".
				En la carpeta src es donde vas a realizar todo tu trabajo como desarrollador.
				- Verás además varios archivos .ts, que son código fuente TypeScript. Como quizás sepas, los archivos .ts
				solo existen en la etapa de desarrollo, es decir, en el proyecto que el navegador debe consumir no
				encontrarás archivos .ts, básicamente porque el navegador no entiende TypeScript. Esos archivos son los
				que se compilarán para producir el código .js que sí entienda el navegador.
		- Carpeta e2e: para pruebas end to end
		- dist: Es la versión de tu aplicación que subirás al servidor web para hacer público el proyecto. En dist aparecerán todos los archivos 
			que el navegador va a necesitar y nunca código fuente en lenguajes no interpretables por él. (Observa que no hay archivos .ts dentro de dist).

	- Archivo app.module.ts
		- módulo principal de la aplicación
		- Import de nuestro componente raíz --> import { AppComponent } from './app.component';
		- Decorador @NgModule
			Los decoradores son algo que viene directamente otorgado por TypeScript. Permiten asignar metadata a funciones, clases u otras cosas. 
			Las funciones decoradoras tienen un nombre y las usamos para asignar esos datos, que podrían modificar el comportamiento de aquello que se está decorando.

	- Alterando el código de nuestro componente

		<h1>
			{{title}}
		</h1>
		<p [hidden]="!visible">
			Adiós
		</p>
		<button (click)="decirAdios()">Decir adiós</button>

		En este HTML tenemos:
		- expresión, entre llaves dobles, que permite volcar el contenido de propiedades del componente. 
		- uso de una propiedad de un elemento, como es "hidden", entre corchetes (nuevo en Angular2). 
		- declaración de un evento "click" que se coloca entre parénteis.

	- Piezas declarables en una vista
		- Propiedad: Cualquier valor que podemos asignar por medio de un atributo del HTML. Ese elemento puede ser simplemente un atributo del HTML 
			estándar, un atributo implementado mediante el propio Angular 2 o un atributo personalizado, creado para un componente en específico.
		- Expresión: Es un volcado de cualquier información en el texto de la página, como contenido a cualquier etiqueta. 
			La expresión es una declaración que Angular procesará y sustituirá por su valor, pudiendo realizar sencillas operaciones.
		- Binding: Es un enlace entre el modelo y la vista. Mediante un binding si un dato cambia en el modelo, ese cambio se representa en la vista.
			Pero además en Angular se introduce el "doble binding", por el cual si un valor se modifica en la vista, 
			también viaja hacia el modelo. Con la novedad en Angular (2 en adelante) que el doble binding es opcional.
		- Evento: es un suceso que ocurre y para el cual se pueden definir manejadores, que son funciones que se ejecutarán como respuesta a ese suceso

	- Ejemplos de sintaxis utilizada en vistas de Angular 2
		- Propiedades
			[hidden]="!visible", [class]="clase", [href]="enlace"
		- Expresiones
			{{title}}, href="{{enlace}}"
		- Eventos
			<button (click)="decirAdios()">Decir adiós</button>
		- Doble binding: el valor está en los 2 sitios, modelo y vista
			¿Cómo te llamas? <input type="text" [(ngModel)]="quien"> --> ese quien 



- Angular Pagina Oficial

- Flujo de la información de la vista al modelo y modelo a vista
	- Estructura de angular MVVM: Modelo Vista - Vista Modelo --> Modelo: .ts o controlador, Vista: html
	1. Las propiedades tienen un flujo desde el modelo a la vista. Una información disponible en el modelo se puede asignar como valor en un elemento 
		del HTML mediante una propiedad, usando la notación corchetes. Por ej: [propiedad]
	2. Las expresiones también viajan desde el modelo a la vista. La diferencia de las propiedades es que en este caso las usamos como contenido 
		de un elemento y además que se expresan con dobles llaves. Por ej: {{expresión}}
	3. El binding (a dos sentidos, o doble binding) lo expresamos entre corchetes y paréntesis. 
		En este caso la información fluye en ambos sentidos, desde el modelo a la vista y desde la vista al modelo. Por ej: [(ngBind)]
	4. Los eventos no es que necesariamente hagan fluir un dato, pero sí se considera un flujo de aplicación, en este caso de la vista al modelo, 
		ya que se originan en la vista y generalmente sirven para ejecutar métodos que acabarán modificando cosas del modelo. Por ej: (evento)
	
	
-------------------------------------------------------------------


05/02/2020

- Directivas:
	- una directiva es una propiedad de la etiqueta/atributo que lo lleva
	- *ngIf, *ngFor, *ngSwitch son ejemplos de directivas
	- 3 tipos: 
		- Components: son directivas con una plantilla de html. Un componente y una directiva son prácticamente lo mismo
		- Estructurales: cambian el DOM añadiendo o removiendo elementos, por jemplo *ngIf.
		- Attribute directive: cambian la apariencia de un elemento del DOM, por ejemplo NgStyle. --> hidden, disabled

	- ¿Cómo creo una directiva? 
		ng generate directive $nombre_de_nuestra_directiva --> ng g d directivas/hello
		- decorador @Directive con una propiedad “selector” donde pondremos el nombre de nuestra directiva. 
			El nombre que pongamos en esta propiedad será el mismo nombre que tendrá el atributo html.
		- ElementRef: es una referencia al elemento html que contiene la directiva. Sólo hay que saber cómo se accede 
			--> en nuestro ejemplo sería el "p" que contiene appHello
			 hay que inyectársela al constructor --> constructor(private element: ElementRef){}
		- @HostListener: Nos da la capacidad de escuchar eventos del elemento que contiene la directiva. 
			Nuestros ‘mouseenter’ y ‘mouseleave’ (cuando ratón entra y ratón sale). Justo debajo la función que se va a ejecutar cuando ocurra.
		- Es importantes no olvidarnos de importar HostListener y ElementRef


- Pipes o Filtros
	- nos permiten alterar la forma en la que se van a visualizar los datos --> transformar cosas
	- docu oficial --> https://angular.io/guide/pipes
	- filtros de angular --> https://angular.io/api?type=pipe
		- UpperCasePipe --> {{ value_expression | uppercase }} --> pasa el texto a mayúsculas
		- CurrencyPipe  --> {{ value_expression | currency [ : currencyCode [ : display [ : digitsInfo [ : locale ] ] ] ] }} --> formato moneda
			los [ indican que es un campo opcional
	- nosotros podemos crear nuestros propios filtros
		ng g pipe pipes/animales



-------------------------------------------------------------------


10/02/2020


- Observables
	- se usan con el servicio rest para hacer llamadas asíncronas
	- ver en github proyecto angularApp: página y servicio tareas en angularApp --> CRUD de tareas sobre servicio rest
	- db.json: 
		//nuevo array de tareas:
  		"tareas": [
    		//objeto json:
    			{
      			"id": 1,
      			"titulo": "",
      			"completada": true
    			}

  		],

	- Creamos servicio: ng g s services/tareas
	- Abrir puerto para ver json que acabamos de crear: json-server --watch db.json --> http://localhost:3000/tareas
	- Creamos página para tareas : ng g c paginas/tareas

	- ver inspector del navegador --> network --> XHR (son las peticiones ajax)

	- librería RxJS para observables (es programación reactiva) --> https://rxjs-dev.firebaseapp.com/
	- El "por qué" de los observables
		- "Observable", que básicamente nos ahorra tener que hacer consultas repetitivas de acceso a la fuente de información, aumentando el rendimiento de las aplicaciones.
	- Programación reactiva	
		- Programación tradicional: las instrucciones se ejecutan una detrás de otra: 

			let a = 1;
			let b = 3;
			let resultado = a + b; // resultado vale 4
			// Más tarde en las instrucciones... 
			a = 7; // Asignamos otro valor a la variable a
			// Aunque se cambie el valor de "a", resultado sigue valiendo 4,

			en programación reactiva, resultado = 10: 
			es decir, la variable resultado habría actualizado su valor al alterarse las variables con las que se realizó el cálculo

		- Programación reactiva y los flujos de datos
			- La programación reactiva es la programación con flujos de datos asíncronos
			- En la programación reactiva se tienen muy en cuenta esos flujos de datos, creando sistemas que son capaces de consumirlos 
			de distintos modos, fijándose en lo que realmente les importa de estos streams y desechando lo que no. 
			Para ello se dispone de diversas herramientas que permiten filtrar los streams, combinarlos, crear unos streams a partir de otros, 
			etc. --> funciones map, filter, reduce...
			- Como objetivo final, reactive programing se ocupa de lanzar diversos tipos de eventos sobre los flujos:
				- La aparición de algo interesante dentro de ese flujo
				- La aparición de un error en el stream
				- La finalización del stream
				son los 3 pasos que hacemos en un servicio rest cuando nos subscribimos: 
				this.pokemonService.getHabilidad( habilidad ).subscribe(
              				json => {
                				...
 					},
      					error => {
          					console.warn('peticion erronea data o%', error);
          					this.mensaje = 'No existe el Pokemon';
      					},
      					() => {
          					console.trace('esto se hace siempre, tanto si funciona como si hay un error');
      					}

	- Observables y programación reactiva
		- Observable: aquello que queremos observar
			Un observable se puede crear por eventos de usuario derivados de un formulario, una llamada HTTP, un almacén de datos, etc. 
			Mediante el observable nos podemos suscribir a eventos que nos permiten hacer cosas cuando cambia lo que se esté observando.
		- Observer: es el typescript, cuando nos subscribimos al observable
		- Subject: es el emisor de eventos, que es capaz de crear el flujo de eventos cuando el observable sufre cambios. 
			Esos eventos serán los que se consuman en los observers.

	- Qué es RxJS
		- librería para implementar programación reactiva que hacen uso del patrón observable
		- get, put, post, delete devuelven observables de cualquier tipo

	- ¿Qué necesitamos para implementar observables?
		- Un subject: que es el encargado de generar y emitir los eventos de actualización del almacén de datos.
		- Un observable: que es un objeto que permite observar los eventos emitidos por el subject.
		- Una suscripción: generada a partir del observable.


-------------------------------------------------------------------


11/02/2020

Vamos a habilitar una zona privada a la que sólo se podrá entrar si se tienen permisos (login)

1) Creamos una página "privado" y la protegemos creando una guarda:
	- ng g c paginas/privado --> de momento sólo usamos el .html para escribir un poco de teoría
	- Para proteger el acceso a esta ruta debemos usar una GUARDA / GUARD y definirla en el routing:
		{ path: 'privado', component: PrivadoComponent, canActivate: [LoginGuard] }
		canActivate: Guarda para indicar si se puede ativar esa ruta
		LoginGuard: Guarda creada por nosotros, que devuelve un true (sí tenemos permisos para entrar) o un false (no tenemos permisos para activarlo)
	- creamos guarda: ng g g guards/login --> seleccionar con el espacio la opción de canActivate e intro
		login.guard.ts :
		//para poder redireccionar al usuario (si sus credenciales no son correctas), necesitamos inyectarlo en el constructor
  		constructor( private router : Router, private usuarioService: UsuarioService){
		    console.debug('LoginGuard constructor');
		}//fin constructor

2) Creamos una clase usuario.ts (con id, nombre y password), una interfaz IUsuario.service.ts y usuario.service.ts para implementar la interfaz

ng g c paginas/login

ng g s services/usuario 

privado.component.html .ts y .scss
login.guard.ts
usuario.ts
usuario.service.ts
IUsuario.service.ts

login.component.html .ts y .scss


3) Formularios reactivos: 
	- creamos página de login: login.component.html .ts y .scss
	- Son mejores para formularios en los que queremos aplicar validaciones y habilitar/deshabilitar el botón de submit
	- [(ngModel)] está bien para cosas más sencillas

	- Cosas importantes cuando usamos formularios reactivos:
		- Formulario de tipo FormGroup --> 
			(.ts) formulario: FormGroup;
		- Hay que importar el módulo de angular ReactiveFormsModule en 2 sitios dentro de app.modules.ts:
			1) import { FormsModule, ReactiveFormsModule } from '@angular/forms';
			2) imports: [
    				BrowserModule,
    				HttpClientModule, //módulo para llamadas por http
    				FormsModule, //módulo para usar formularios con banana in a box
    				ReactiveFormsModule, //módulo para usar formularios reactivos
    				AppRoutingModule
  			]
		- Inyectar en el constructor: private builder: FormBuilder --> 
			(.ts) constructor( private builder: FormBuilder) {} (y lo importamos en el ts claro, import { FormGroup, FormBuilder, Validators } from '@angular/forms';)
		- FormControl = input

	- https://angular.io/api/forms/FormControl: 
		- value: any
		- valid: boolean
		- pristine: boolean
  		- dirty: boolean
  		- touched: boolean
  		- untouched: boolean

comentario github con todo lo que hemos hecho hasta ahora: privado con guarda para proteger e inicio login

-----

12/02/2020

4) Login funcionando y habilitada la zona privada y cerrar sesión sólo si el usuario está logeado:
	- rutas.ts
	- navbar.component.html y navbar.component.ts
	- login.guard.ts
	- login.component.ts
	- usuario.service.ts
	- comentario github: Login funcionando, backoffice y cerrar sesión

-----

13/02/2020

- sessionStorage
	- https://developer.mozilla.org/es/docs/Web/API/Window/sessionStorage
	- La propiedad sessionStorage permite acceder a un objeto Storage asociado a la sesión actual. 
	La propiedad sessionStorage es similar a localStorage, la única diferencia es que la información almacenada en localStorage no posee tiempo de expiración, 
	por el contrario la información almacenada en sessionStorage es eliminada al finalizar la sesion de la página. 
	La sesión de la página perdura mientras el navegador se encuentra abierto, y se mantiene por sobre las recargas y reaperturas de la página. 
	Abrir una página en una nueva pestaña o ventana iniciará una nueva sesión, lo que difiere en la forma en que trabajan las cookies de sesión.

	- Sintaxis:
		sessionStorage.setItem('key', 'value'); // Almacena la información en sessionStorage
		var data = sessionStorage.getItem('key'); // Obtiene la información almacenada desde sessionStorage


- Preparando filtro por habilidad pokemon con checkbox:
	- Ver ejercicio arrays de angular App:

	1) tenemos que quedarnos con las habilidades del pokemon:
	this.colores = this.frutas.reduce( (p, c, i, a) => {
      return p.concat(c.colores);   //va guardando en un array todos los colores que va encontrando en cada fruta (estarán repetidos)
      }, [] ).filter( (el, index, array) => {  //con filter vamos recorriendo el array de colores y vamos guardando el 1ero que aparezca
          console.debug(el, index, array);
          return array.indexOf(el) === index;
    });


-------------------------------------------------------------------


14/02/2020

- Input y Output en Angular

	- objetivo: interacción entre componentes
	- Los inputs nos permiten pasar valores desde el componente “padre” que utiliza dentro del el otro componente y así intercambiar datos entre estos dos componentes. 
	- utilizando el decorador @Input recibo los datos desde el otro componente 
	- También podemos pasarle datos del componente “hijo” al componente padre que lo utiliza con Output.

	- Ver ejemplo en proyecto angularApp página compras:

		Ver listado.component.ts:
    		(pasameFrutaEvento)="recogerEvento($event)"
    		@Output() pasameFrutaEvento = new EventEmitter();
    		es un evento de tipo Output y se expresa con ()
    
		[frutas]="frutas"
    		@Input() frutas = Array<Fruta>();
    		es un evento de tipo Input y se expresa con []


Hasta aquí hacemos un test de 20 preguntas


-------------------------------------------------------------------


21/02/2020

- Variables del entorno con Angular

	- en modo producción, los archivos JS de Angular serán servidos en la misma URL que los de PHP, así que la URL base es: .
	En cambio, en modo desarrollo, Angular es servido en una URL distinta y la URL es: localhost/mascotas_angular
	Hay que cambiar esto para que al compilar con la cli usando ng build --prod se cambie el valor automáticamente.
	- ng build --prod --> en carpeta dist genera todos los archivos comprimidos (css, ts...)
	- Diferente valor en cada entorno
		mismos datos pero diferentes valores según estemos en desarrollo o producción
		se guardan en:
			environment.prod.ts --> coge el fichero para producción
			environment.ts --> coge el fichero para local host
			con estos 2 ficheros configurar variables distintas en cada caso para desarrollo y produccion (*)
	- Las variables no serán tomadas en cuenta si solo haces un ng build; debes hacer un ng build --prod para crear un “build de producción”
	

hasta aquí hacemos un test de 20 preguntas

--

html de la lista:
<a [routerLink]="['/libro',libro.id]">pincha para ir al detalle</a>

página detalle:
inyectar en el constructor router y service
en ngOnInit --> this.route.params.subscribe( params => this.idLibro = params.pIdLibro ); //params devuelve un observable --> nos tenemos que suscribir

ng new UF1644-Ana

ng g c paginas/inicio
ng g c componentes/navbar

ng g c paginas/detalle
ng g c paginas/formulario

--

* Producción y variables de entorno:
- Angular Subir a Producción --> ng build --prod
- cuando subimos a producción una app de angular, se genera 1 fichero javascript para todo el typescript
- trazas necesarias para una aplicación de java en produccion --> En producción se suele cambiar a INFO o WARN
- carpeta en la que se guardan los ficheros de angular que desarrollamos --> carpeta src
- carpeta en la que se guardan los ficheros de producción de angular --> carpeta dist
	carpetas como "test" o "dist", para realizar el test o para almacenar los archivos listos para producción.
- acceso a info necesaria en angular --> servicio o provider
- ficheros de java para ejecutarse en desarrollo --> .java
- ficheros de java para ejecutarse en produccion --> .class
- ficheros para entorno desarrollo angular --> ts y scss
- ficheros para entorno produccion angular --> javascripts y css
- servidor para desarrollar en angular --> node js
- carpeta donde se despliegan las apps dentro de tomcat --> webapp
- sistema de trazas de java cuando la app está publicada --> log4j
- es aconsejable usar trazas/logs cuando se publica una aplicación
- ¿se pueden poner breakpoints en una aplicación de angular en producción?
- ¿se pueden poner breakpoints en una aplicación de java en producción?
- en angular no se necesita escribir sentencias SQL
- para acceder a la info necesaria en angular se usan servicios o providers
- gracias a las variables del entorno, en angular podemos configurar distintas variables en la carpeta environment
	distinguiendo los casos de desarrollo y producción
- en java también podemos hacer esta diferencia entre las variables de desarrollo y producción, 
	pero las guardamos en la carpeta src/resources


-------------------------------------------------------------------


25/02/2020

UF1644 - Canales de distribución y publicación utilizados en los sistemas gestores de información (21/02/2020)

en el test de este módulo han entrado preguntas sobre producción java/angular y variables de entorno

- CheckStyle instalación
	- Checkstyle es una herramienta de desarrollo que ayuda a los programadores a escribir código Java adecuándose a estándares de codificación 
	establecidos, facilitando para ello la automatización del proceso de chequeo del código generado.
	- Checkstyle incorpora las recomendaciones de Sun sobre el estilo de código, pero estas reglas pueden ser redefinidas e 
	incluso creadas completamente desde cero por el usuario, lo que convierte este plug-in en adaptable al estilo de codificación interno 
	de nuestro entorno, sea cual sea.

- PMD
	- PMD es una herramienta que comprueba que nuestra aplicación cumpla una serie de reglas que nos ayudan a obtener un código más elegante, 
	sencillo y mantenible. 
	- Estas reglas se agrupan por conjuntos y pueden ser reglas de complejidad, como que la complejidad ciclomática no sea demasiado alta; 
	de diseño, como no usar interfaces como meros contenedores de constantes; de optimización, como procurar usar ArrayList en lugar de Vector; etc.

-------------------------------------------------------------------

26/02/2020

- Fixing deep linking issue – Deploying angular application on Tomcat server

	- Objetivo: Soluciar problemas de construcción de enlaces en angular

	- Angular es client side y sigue la estructura SPA (Single Page Application), por lo tanto, tenemos que realizar una configuración para permitir
	acceder a un recurso determinado introduciendo manualmente la URI del mismo,
	Si realizamos una nueva petición a cualquier URI que no sea la raiz del proyecto, nos dará un error 404 porque no encuentra el recurso solicitado.
	
	- Para reparar este fallo, tenemos que configurar el servidor de tomcat para redirigir los links a nuestra página proncipal.
	Es necesario seguir los siguientes pasos en el servidor:

	1- Configurar el archivo server.xml (RewriteValve)
		Dentro de la etiqueta <host> del fichero de configuración server.xml tenemos que escribir la siguiente línea:
		<Valve className="org.apache.catalina.valves.rewrite.RewriteValve" />

	2- Escribir el RewriteValve en el fichero rewrite.config
		Para esto creamos un fichero llamado rewrite.config dentro de /conf/catalina/localhost
		En ese fichero escribimos las siguientes líneas:
		RewriteCond %{REQUEST_PATH} !-f
		RewriteRule ^/nombre-proyecto-angular/(.*) /nombre-proyecto-angular/index.html

	(que no se nos olvide añadir una ruta que nos lleve al InicioComponent en nuestra aplicación de angular, para que si hay algún error,
	el usuario sea redireccionado a esa página:
	en	app-routing.module.ts	añadimos   {path: '**', component: InicioComponent} 
	)

- Activar CORS en Tomcat
	Además de activar CORS en nuestros controladores, cuando subimos un proyecto a producción también debemos activar CORS en Tomcat.
	Para ello debemos meter las siguientes lineas en este fichero $CATALINA_BASE/conf/web.xml y reiniciar tomcat

<filter>
    <filter-name>CorsFilter</filter-name>
    <filter-class>org.apache.catalina.filters.CorsFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>CorsFilter</filter-name>
    <url-pattern> /* </url-pattern>
</filter-mapping>






